# .github/workflows/ci-cd-pipeline.yml
name: Flask App CI/CD to AKS

on:
  # Trigger the workflow on pushes to the 'main' branch
  push:
    branches: [ "main" ]
  # Allow manual trigger from the GitHub Actions UI (optional, but useful)
  workflow_dispatch:

# Define environment variables used throughout the workflow
env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }} # e.g., flasktodocrgamedream90.azurecr.io
  IMAGE_NAME: todo-flask                          # Must match the image name in deployment.yaml
  IMAGE_TAG: ${{ github.sha }}                    # Use the unique commit hash as the image tag
  K8S_PATH: kubernetes                            # Directory containing Kubernetes manifests

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: ‚¨áÔ∏è Checkout Repository
      uses: actions/checkout@v4

    # ----------------------------------------------------
    # 1. CI: Log in to Azure and ACR
    # ----------------------------------------------------
    - name: üîê Azure Login
      uses: azure/login@v1.4.6
      with:
        # Uses the JSON Service Principal credentials secret
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: üîê Docker Login to ACR
      uses: azure/docker-login@v1.5.1
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        # ACR login uses the client ID and secret from the Service Principal
        username: ${{ secrets.CLIENT_ID }} 
        password: ${{ secrets.CLIENT_SECRET }} 
        
    # ----------------------------------------------------
    # 2. CI: Build and Push Docker Image
    # ----------------------------------------------------
    - name: üõ†Ô∏è Build and Tag Docker Image
      run: |
        # Build the image using the full path: ACR_LOGIN_SERVER/IMAGE_NAME:IMAGE_TAG
        docker build -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} ./todolist 

    - name: ‚¨ÜÔ∏è Push Docker Image to ACR
      run: |
        docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

    # ----------------------------------------------------
    # 3. CD: Prepare and Deploy to AKS
    # ----------------------------------------------------
    
    # NEW STEP: Use the Azure action to connect to AKS
    - name: ü§ù Get AKS Credentials (Connect to AKS)
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ secrets.RESOURCE_GROUP }}
        cluster-name: ${{ secrets.CLUSTER_NAME }}
        
    # NEW STEP: Update the image tag in the K8s deployment file (Recommended fix)
    - name: üìù Update K8s Deployment Image Tag
      uses: azure/k8s-set-service-acr-image@v1 
      with:
        # Path to the Kubernetes Deployment manifest
        manifests: ${{ env.K8S_PATH }}/deployment.yaml 
        # The full image name to be injected into the deployment file
        image-names: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        # The specific container name within the deployment to update
        container-name: todo-flask-app 

    - name: üöÄ Deploy to AKS
      uses: azure/k8s-deploy@v4
      with:
        # Apply both the updated deployment and service manifests
        manifests: |
          ${{ env.K8S_PATH }}/deployment.yaml
          ${{ env.K8S_PATH }}/service.yaml
        action: deploy # Action to apply the manifests

    - name: üîé Verify Deployment and Get Load Balancer IP
      run: |
        echo "Waiting for LoadBalancer IP..."
        # Wait for the LoadBalancer to get an external IP address
        kubectl get service todo-flask-service --watch --timeout=5m