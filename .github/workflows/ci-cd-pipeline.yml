# .github/workflows/ci-cd-pipeline.yml
name: Flask App CI/CD to AKS

on:
  # Trigger the workflow on pushes to the 'main' branch
  push:
    branches: [ "main" ]
  # Allow manual trigger from the GitHub Actions UI
  workflow_dispatch:

# Define environment variables used throughout the workflow
env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }} 
  IMAGE_NAME: todo-flask                          
  IMAGE_TAG: ${{ github.sha }}                    
  K8S_PATH: kubernetes                            

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: ‚¨áÔ∏è Checkout Repository
      uses: actions/checkout@v4

    # ----------------------------------------------------
    # 1. CI: Log in to Azure and ACR
    # ----------------------------------------------------
    - name: üîê Azure Login
      uses: azure/login@v1 
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: üîê Docker Login to ACR
      uses: azure/docker-login@v1 
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        username: ${{ fromJson(secrets.AZURE_E_CREDENTIALS).clientId }} 
        password: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }} 
        
    # ----------------------------------------------------
    # 2. CI: Build and Push Docker Image
    # ----------------------------------------------------
    - name: üõ†Ô∏è Build and Tag Docker Image
      run: |
        # Use -f flag to specify Dockerfile path and ./todolist as build context
        docker build -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f ./todolist/Dockerfile ./todolist 

    - name: ‚¨ÜÔ∏è Push Docker Image to ACR
      run: |
        docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

    # ----------------------------------------------------
    # 3. CD: Deploy to AKS
    # ----------------------------------------------------
    
    - name: ü§ù Get AKS Credentials
      uses: azure/aks-set-context@v3 
      with:
        resource-group: ${{ secrets.RESOURCE_GROUP }}
        cluster-name: ${{ secrets.CLUSTER_NAME }}

    - name: ‚öôÔ∏è Apply K8s Manifests (Create Service & Deployment)
      run: |
        kubectl apply -f ${{ env.K8S_PATH }}/service.yaml
        kubectl apply -f ${{ env.K8S_PATH }}/deployment.yaml

    - name: üìù Patch Deployment Image
      run: |
        kubectl set image deployment/${{ env.IMAGE_NAME }}-deployment ${{ env.IMAGE_NAME }}-app=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        
    # ----------------------------------------------------
    # 4. Monitoring and Verification (NEW DIAGNOSTIC STEP)
    # ----------------------------------------------------
    - name: üîé Verify Deployment Health and Get Logs
      run: |
        echo "Waiting for the new pods to roll out (5m timeout)..."
        # We run 'rollout status' but use '||' to continue if it fails.
        # This allows us to run diagnostics.
        kubectl rollout status deployment/${{ env.IMAGE_NAME }}-deployment --timeout=5m || echo "Rollout timed out. Collecting diagnostics..."
        
        # --- DIAGNOSTICS ---
        
        # 1. Get detailed pod status (shows CrashLoopBackOff or ImagePullBackOff)
        echo "--- Pod Status after Rollout ---"
        kubectl get pods -l app=${{ env.IMAGE_NAME }} --show-labels
        
        # 2. Get events from the ReplicaSet to find the root cause
        echo "--- Kubernetes Events for Deployment ---"
        # Get the ReplicaSet associated with the deployment
        NEW_REPLICASET_NAME=$(kubectl describe deployment ${{ env.IMAGE_NAME }}-deployment | grep "NewReplicaSet" | awk '{print $2}')
        if [ ! -z "$NEW_REPLICASET_NAME" ]; then
          echo "--- Events for new ReplicaSet ($NEW_REPLICASET_NAME) ---"
          kubectl describe replicaset $NEW_REPLICASET_NAME
        else
          echo "Could not find new ReplicaSet to describe events."
        fi
        
        # 3. Get container logs (This is the most critical info)
        echo "--- Logs from a Failing Pod ---"
        # Find the name of one of the newly created pods
        POD_NAME=$(kubectl get pods -l app=${{ env.IMAGE_NAME }} -o jsonpath='{.items[0].metadata.name}')
        if [ ! -z "$POD_NAME" ]; then
          # Get logs from the *previous* container instance if it crashed
          echo "--- Logs from *previous* container (if it crashed) ---"
          kubectl logs --previous $POD_NAME || echo "No previous container logs found."
          echo "--- Logs from *current* container ---"
          kubectl logs $POD_NAME
        else
          echo "Could not find a pod name to fetch logs."
        fi
        
        # --- Final Check for IP ---
        echo "--- Final LoadBalancer IP Check ---"
        kubectl get service ${{ env.IMAGE_NAME }}-service
        
        # --- Final Step: Re-check rollout to fail the job if it truly failed ---
        echo "--- Final Rollout Check ---"
        # This command will fail the job if the rollout didn't succeed
        # after all diagnostics are printed.
        kubectl rollout status deployment/${{ env.IMAGE_NAME }}-deployment --timeout=10s