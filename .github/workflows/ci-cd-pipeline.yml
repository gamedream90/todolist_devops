# .github/workflows/ci-cd-pipeline.yml
name: Flask App CI/CD to AKS

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }} 
  IMAGE_NAME: todo-flask                          
  IMAGE_TAG: ${{ github.sha }}                    
  K8S_PATH: kubernetes                            
  FULL_IMAGE_NAME: ${{ secrets.ACR_LOGIN_SERVER }}/todo-flask:${{ github.sha }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: ‚¨áÔ∏è Checkout Repository
      uses: actions/checkout@v4

    # ----------------------------------------------------
    # 1. CI: Log in to Azure and ACR
    # ----------------------------------------------------
    - name: üîê Azure Login
      uses: azure/login@v1 
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: üîê Docker Login to ACR
      uses: azure/docker-login@v1 
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        username: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }} 
        password: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }} 
        
    # ----------------------------------------------------
    # 2. CI: Build and Push Docker Image
    # ----------------------------------------------------
    - name: üõ†Ô∏è Build and Tag Docker Image
      run: |
        docker build -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} ./todolist 

    - name: ‚¨ÜÔ∏è Push Docker Image to ACR
      run: |
        docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

    # ----------------------------------------------------
    # 3. CD: Deploy to AKS
    # ----------------------------------------------------
    
    # Connects to AKS (essential for running kubectl commands)
    - name: ü§ù Get AKS Credentials
      uses: azure/aks-set-context@v3 
      with:
        resource-group: ${{ secrets.RESOURCE_GROUP }}
        cluster-name: ${{ secrets.CLUSTER_NAME }}

    # --- NEW RELIABLE DEPLOYMENT APPROACH ---

    # Step 3A: Deploy the Service (This rarely changes)
    - name: üöÄ Deploy Kubernetes Service
      uses: azure/k8s-deploy@v4
      with:
        manifests: ${{ env.K8S_PATH }}/service.yaml
        action: deploy

    # Step 3B: Apply the Deployment manifest for the first time
    # This creates the deployment resource.
    - name: ‚öôÔ∏è Create or Update Deployment Resource
      uses: azure/k8s-deploy@v4
      with:
        manifests: ${{ env.K8S_PATH }}/deployment.yaml
        action: deploy

    # Step 3C: Patch the Deployment with the new image tag (The reliable update method)
    - name: üìù Patch Deployment Image
      run: |
        # Use kubectl to patch the 'todo-flask-deployment' to use the new image hash
        kubectl set image deployment/todo-flask-deployment todo-flask-app=${{ env.FULL_IMAGE_NAME }}
        
    # ----------------------------------------------------
    # 4. Monitoring and Verification
    # ----------------------------------------------------
    - name: üîé Verify Deployment and Get Load Balancer IP
      run: |
        echo "Waiting for the new pods to roll out..."
        kubectl rollout status deployment/todo-flask-deployment --timeout=5m
        echo "Waiting for LoadBalancer IP (This may take a few minutes for the first run)..."
        kubectl get service todo-flask-service --watch --timeout=5m